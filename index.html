<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Meta: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Meta
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A tiny metaprogramming library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<p> <em>Meta</em> is a C++11 tiny metaprogramming library developed by <a href="https://github.com/ericniebler">Eric Niebler</a>.</p>
<p>It is released under the Boost Software License and it is header only, that is, to compile with meta you just have to:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="meta_8hpp.html">meta/meta.hpp</a>&gt;</span></div>
</div><!-- fragment --> <hr/>
<p>The documentation of <em>Meta</em> is currently scarce. The best resources are the <a href="group__meta.html">Reference</a> and the <a href="examples.html">Examples</a>.</p>
<p>As a motivation and introduction to the library you can read <a href="http://ericniebler.com/2014/11/13/tiny-metaprogramming-library/">Eric's original blog post</a>, but please keep in mind that the library has evolved quite a bit since then. </p><hr/>
<h2>Tutorial</h2>
<p>The tutorial begins with a brief introduction to metafunctions, metafunction classes, and type lists. Then it moves to metafunction composition and currying. Finally, it covers type list algorithms and algorithms for working on integer sequences.</p>
<h3>Metafunction</h3>
<p>Metafunctions are functions that operate on types. For example,</p>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    <span class="keyword">struct </span>mf</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> type = void;</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">using</span> result = <span class="keyword">typename</span> mf&lt;int, double&gt;::type;</div>
<div class="line">    static_assert(std::is_same&lt;result, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> is a metafunction taking an arbitrary number of types that always returns void. The return value of a meta function is obtained from a nested type alias called (by convention) <code>type</code>. All of the metafunctions in the C++11 standard library follow this convention. C++11 template aliases allow us to write:</p>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    <span class="keyword">using</span> mf_t = <span class="keyword">typename</span> mf&lt;Args...&gt;::type;</div>
<div class="line">    <span class="keyword">using</span> result = mf_t&lt;int, double&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;result, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> and thus to omit the <code>typename X::type</code> when calling a metafunction. C++14 standard library provides <code>_t</code> metafunction aliases for all the metafunctions in the standard library.</p>
<p><em>Meta</em> provides <code><a class="el" href="group__invocation.html#gaef73a6f4def71032bfa868bc2b27544c" title="&quot;Evaluate&quot; the metafunction T by returning the nested T::type alias. ">meta::eval</a>&lt;T&gt;</code>, which evaluates the metafunction <code>T</code> by returning the tested <code>T::type</code> alias. This allows metafunction aliases to be written as follows:</p>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    <span class="keyword">using</span> mf2_t = <a class="code" href="group__invocation.html#gaef73a6f4def71032bfa868bc2b27544c">meta::eval</a>&lt;mf&lt;Args...&gt;&gt;;</div>
<div class="line">    <span class="keyword">using</span> result = mf2_t&lt;int, double&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;result, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <h3>Metafunction Class</h3>
<p>A Metafunction Class is a form of metafunction suitable for higher-order metaprogramming. It is a class with a nested metafunction called (by convention) <code>apply</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">struct </span>mfc</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">        <span class="keyword">using</span> <a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">apply</a> = void;</div>
<div class="line">    };</div>
</div><!-- fragment --><p> <em>Meta</em> provides the <code><a class="el" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec" title="Evaluate the Metafunction Class F with the arguments Args. ">meta::apply</a>&lt;F, Args...&gt;</code> metafunction that evaluates the metafunction class <code>F</code> with the arguments <code>Args</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> result = mfc::apply&lt;int, double&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;result, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To turn a metafunction into a metafunction class <em>Meta</em> provides the <code><a class="el" href="structmeta_1_1quote.html" title="Turn a class template or alias template C into a Metafunction Class. ">meta::quote</a>&lt;F&gt;</code> metafunction:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> mf_class0 = <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;mf&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> result0 = <a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">meta::apply&lt;mf_class0, int, double&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;result0, mf&lt;int, double&gt;&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(std::is_same&lt;<a class="code" href="group__invocation.html#gaef73a6f4def71032bfa868bc2b27544c">meta::eval&lt;result0&gt;</a>, <span class="keywordtype">void</span>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> mf_class1 = <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;mf_t&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> result1 = <a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">meta::apply&lt;mf_class1, int, double&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;result1, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Note that in the first case we create a metafunction class that will evaluate the metafunction through apply, while in the second case we create a metafunction class containing the already evaluated result.</p>
<h3>Composition</h3>
<p>Multiple metafunctions classes can be composed into a single metafunction using <code><a class="el" href="structmeta_1_1compose.html" title="Compose the Metafunction Classes Fs in the parameter pack Ts. ">meta::compose</a>&lt;F0, F1, ..., FN&gt;</code>, which returns a new metafunction class that performs <code>FN(... (F1(F0(Args...)) )</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keyword">using</span> mf0 = <a class="code" href="group__invocation.html#gaef73a6f4def71032bfa868bc2b27544c">meta::eval&lt;std::make_signed&lt;T&gt;</a>&gt;;</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keyword">using</span> mf1 = <a class="code" href="group__invocation.html#gaef73a6f4def71032bfa868bc2b27544c">meta::eval&lt;std::add_const&lt;T&gt;</a>&gt;;</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keyword">using</span> mf2 = <a class="code" href="group__invocation.html#gaef73a6f4def71032bfa868bc2b27544c">meta::eval&lt;std::add_lvalue_reference&lt;T&gt;</a>&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> mf = <a class="code" href="structmeta_1_1compose.html">meta::compose&lt;meta::quote&lt;mf2&gt;</a>, <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;mf1&gt;</a>, <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;mf0&gt;</a>&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;<a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">meta::apply&lt;mf, unsigned&gt;</a>, <span class="keywordtype">int</span> <span class="keyword">const</span> &amp;&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <h3>Partial function application (currying)</h3>
<p>Partial application is provided by binding a type to an argument of the metafunction using, e.g., <code><a class="el" href="structmeta_1_1bind__front.html" title="A Metafunction Class that partially applies the Metafunction Class F by binding the arguments Ts to t...">meta::bind_front</a></code> and <code>meta::bind*back</code> to bind a type to the first/last argument. That way, we can, e.g., create a metafunction that returns <code>true</code> if a type is the same as <code>float</code> by reusing the <code>std::is_same</code> metafunction:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> is_float = <a class="code" href="structmeta_1_1bind__front.html">meta::bind_front&lt;meta::quote&lt;std::is_same&gt;</a>, <span class="keywordtype">float</span>&gt;;</div>
<div class="line">    static_assert(<a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">meta::apply&lt;is_float, float&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(!<a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">meta::apply&lt;is_float, double&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> is_float2 = <a class="code" href="structmeta_1_1bind__back.html">meta::bind_back&lt;meta::quote&lt;std::is_same&gt;</a>, <span class="keywordtype">float</span>&gt;;</div>
<div class="line">    static_assert(<a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">meta::apply&lt;is_float2, float&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(!<a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">meta::apply&lt;is_float2, double&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>TODO: <code><a class="el" href="group__composition.html#ga208c20d6d38a9efe6230dd116bd20758" title="A Metafunction Class that takes a bunch of arguments, bundles them into a type list, and then calls the Metafunction Class F with the type list Q. ">meta::curry</a></code> / <code><a class="el" href="group__composition.html#ga6aea9f402682b7b31ec467a96c3ee4cd" title="A Metafunction Class that takes a type list, unpacks the types, and then calls the Metafunction Class...">meta::uncurry</a></code> </p>
</blockquote>
<h3>Logical operations</h3>
<p>The metafunctions <code><a class="el" href="group__logical.html#ga56a131a7be37d706a5f85f5fcab6d5f2" title="Select one type or another depending on a compile-time Boolean. ">meta::if_</a></code>, <code><a class="el" href="group__logical.html#ga336f87c76347f4d2df7787321fd7d2e3" title="Logically and together all the integral constant-wrapped Boolean parameters, with short-circuiting...">meta::and_</a></code>, <code><a class="el" href="group__logical.html#ga9ca5af65887ca2392d48c549b5ce0951" title="Logically or together all the integral constant-wrapped Boolean parameters, with short-circuiting. ">meta::or_</a></code>, and <code><a class="el" href="group__logical.html#ga9574392c8ceafc6a6007163877452daa" title="Logically negate the integral constant-wrapped Boolean parameter. ">meta::not_</a></code> cover the basic logical operations with types:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> t0 = <a class="code" href="group__logical.html#ga56a131a7be37d706a5f85f5fcab6d5f2">meta::if_&lt;std::is_same&lt;float, double&gt;</a>, <a class="code" href="group__integral.html#ga8cd5c79222ce70365f7469f35ece905a">meta::bool_&lt;true&gt;</a>, <a class="code" href="group__integral.html#ga8cd5c79222ce70365f7469f35ece905a">meta::bool_&lt;false&gt;</a>&gt;;</div>
<div class="line">    static_assert(!t0{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> t1 = <a class="code" href="group__logical.html#ga336f87c76347f4d2df7787321fd7d2e3">meta::and_&lt;meta::bool_&lt;true&gt;</a>, meta::bool_&lt;false&gt;, meta::bool_&lt;true&gt;&gt;;</div>
<div class="line">    static_assert(!t1{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> t2 = <a class="code" href="group__logical.html#ga9ca5af65887ca2392d48c549b5ce0951">meta::or_&lt;meta::bool_&lt;true&gt;</a>, meta::bool_&lt;false&gt;, meta::bool_&lt;true&gt;&gt;;</div>
<div class="line">    static_assert(t2{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> t3 = <a class="code" href="group__logical.html#ga9574392c8ceafc6a6007163877452daa">meta::not_&lt;t1&gt;</a>;</div>
<div class="line">    static_assert(t3{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <h3>Eager and lazy evaluation</h3>
<blockquote class="doxtable">
<p>TODO meta function aliases are eager, <code><a class="el" href="structmeta_1_1defer.html" title="A wrapper that defers the instantiation of a template in a lambda expression. ">meta::defer</a></code>, <code><a class="el" href="namespacemeta_1_1lazy.html" title="Lazy versions of meta actions. ">meta::lazy</a></code> namespace. </p>
</blockquote>
<h3>Lambdas</h3>
<p>Lambda functions allow you to define metafunctions in place:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacemeta_1_1placeholders.html">meta::placeholders</a>;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="group__math.html#gaf4b1427cc9c4040ffca9845c068621ed">greater</a> = <a class="code" href="group__metafunction.html#ga9723a7a839e8753b28083e01db1d2b4d">meta::lambda&lt;_a, _b, meta::lazy::less&lt;_b, _a&gt;</a>&gt;;</div>
<div class="line"></div>
<div class="line">    static_assert(<a class="code" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec">meta::apply</a>&lt;<a class="code" href="group__math.html#gaf4b1427cc9c4040ffca9845c068621ed">greater</a>, <a class="code" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679">meta::size_t&lt;2&gt;</a>, <a class="code" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679">meta::size_t&lt;1&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <h3>Type lists</h3>
<p>A list of types <code>Ts...</code> can be stored in the metafunction <code><a class="el" href="structmeta_1_1list.html" title="A list of types. ">meta::list</a>&lt;Ts...&gt;</code>. It provides a O(1) member function <code><a class="el" href="structmeta_1_1list.html#a1fc19362369fd9373308b9926beac87d">meta::list::size()</a></code> that returns the size of the list.</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> list = <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float&gt;</a>;</div>
<div class="line">    static_assert(<a class="code" href="group__list.html#gad3a42ffe5a3789ca77b32080b1ae6f33">list::size</a>() == 3, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="group__list.html#ga06eaecac4a0a2b60029b30bb2e4bd878">front</a> = <a class="code" href="group__list.html#ga06eaecac4a0a2b60029b30bb2e4bd878">meta::front&lt;list&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;front, int&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="group__list.html#ga3f13cb6243f06ffb4b509709e85ffaf9">back</a> = <a class="code" href="group__list.html#ga3f13cb6243f06ffb4b509709e85ffaf9">meta::back&lt;list&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;back, float&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> at_1 = <a class="code" href="group__list.html#gad6e980f0ae3fcf95b6bbe1eb6593519a">meta::at_c&lt;list, 1&gt;</a>;</div>
<div class="line"></div>
<div class="line">    static_assert(std::is_same&lt;at_1, double&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> index_double = <a class="code" href="group__query.html#ga8cdb5fc30312645f84a60292f9a6aaba">meta::find_index&lt;list, double&gt;</a>;</div>
<div class="line">    static_assert(index_double{} == 1, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> index_char = <a class="code" href="group__query.html#ga8cdb5fc30312645f84a60292f9a6aaba">meta::find_index&lt;list, char&gt;</a>;</div>
<div class="line">    static_assert(index_char{} == <a class="code" href="group__list.html#gac6b96d77cd4223043591fe6e5819ecf8">meta::npos</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    static_assert(!<a class="code" href="group__list.html#gada7280d87ece1a3dc6b203ee0e86e71c">meta::empty&lt;list&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> As you can see, the <code><a class="el" href="group__list.html#ga06eaecac4a0a2b60029b30bb2e4bd878" title="Return the first element in meta::list List. ">meta::front</a>&lt;List&gt;</code>, <code><a class="el" href="group__list.html#ga3f13cb6243f06ffb4b509709e85ffaf9" title="Return the last element in meta::list List. ">meta::back</a>&lt;List&gt;</code>, and <code>meta::list_element_c&lt;std::size_t, List&gt;</code> metafunctions provide access to the elements of the list. The <code><a class="el" href="group__list.html#gada7280d87ece1a3dc6b203ee0e86e71c" title="An Boolean integral constant wrapper around true if List is an empty type list; false, otherwise. ">meta::empty</a>&lt;List&gt;</code> metafunction returns <code>true</code> if the list is empty. The <code>meta::list_element&lt;<a class="el" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679" title="An integral constant wrapper for std::size_t. ">meta::size_t</a>&lt;N&gt;, List&gt;</code> metafunction differs from <code>meta::list_element_c</code> in that it takes a <code><a class="el" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679" title="An integral constant wrapper for std::size_t. ">meta::size_t</a>&lt;N&gt;</code> (<code>std::integral_constant&lt;std::size_t, N&gt;</code>) insted of an integer:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> i = <a class="code" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679">meta::size_t&lt;1&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> at_1 = <a class="code" href="group__list.html#ga15cb412362e286cca6e96f808a3390a4">meta::at&lt;list, i&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;at_1, double&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> You can add and remove elements from a list by using the transformation algorithms:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> l2 = <a class="code" href="group__transformation.html#gadea57dff3ae7e9bf1d0fee072654a55f">meta::push_front&lt;list, char&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;l2, <a class="code" href="structmeta_1_1list.html">meta::list&lt;char, int, double, float&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> l3 = <a class="code" href="group__transformation.html#ga0a9f17db82fc2e4835d2a5424e46d165">meta::pop_front&lt;l2&gt;</a>; <span class="comment">// equivalent to meta::drop&lt;l2&gt;;</span></div>
<div class="line">    static_assert(std::is_same&lt;l3, list&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> l4 = <a class="code" href="group__transformation.html#ga67c3440428c1005a426b67d02a1d73ea">meta::push_back&lt;list, char&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;l4, <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float, char&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> l5 = <a class="code" href="group__transformation.html#ga9898b420663fa75e339e77beed853c9c">meta::drop_c&lt;l4, 3&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;l5, <a class="code" href="structmeta_1_1list.html">meta::list&lt;char&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> You can concatenate, flatten, and zip multiple lists using <code><a class="el" href="group__transformation.html#ga2def322f3d51a997386fd8ee2520da97" title="Concatenates several lists into a single list. ">meta::concat</a>&lt;Lists...&gt;</code>, <code><a class="el" href="group__transformation.html#ga9ff16525d8cace82e7cdcce09854ca1c" title="Joins a list of lists into a single list. ">meta::join</a>&lt;ListOfLists&gt;</code>, and <code><a class="el" href="group__transformation.html#ga6eb038779ea181d1831304d4dcc5677c" title="Given a list of lists of types ListOfLists, construct a new list by grouping the elements from the li...">meta::zip</a>&lt;ListOfLists&gt;</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> list0 = <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> list1 = <a class="code" href="structmeta_1_1list.html">meta::list&lt;&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> list2 = <a class="code" href="structmeta_1_1list.html">meta::list&lt;float, char&gt;</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> concatenated = <a class="code" href="group__transformation.html#ga2def322f3d51a997386fd8ee2520da97">meta::concat&lt;list0, list1, list2&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;concatenated, <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float, char&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> list_of_lists = <a class="code" href="structmeta_1_1list.html">meta::list&lt;list0, list1, list2&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> flattened = <a class="code" href="group__transformation.html#ga9ff16525d8cace82e7cdcce09854ca1c">meta::join&lt;list_of_lists&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;flattened, <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float, char&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> list_of_lists_of_same_length = <a class="code" href="structmeta_1_1list.html">meta::list&lt;list0, list2&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> zipped = <a class="code" href="group__transformation.html#ga6eb038779ea181d1831304d4dcc5677c">meta::zip&lt;list_of_lists_of_same_length&gt;</a>;</div>
<div class="line">    static_assert(</div>
<div class="line">        std::is_same&lt;zipped, <a class="code" href="structmeta_1_1list.html">meta::list</a>&lt;<a class="code" href="structmeta_1_1list.html">meta::list&lt;int, float&gt;</a>, <a class="code" href="structmeta_1_1list.html">meta::list&lt;double, char&gt;</a>&gt;&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>TODO: <code><a class="el" href="group__transformation.html#ga2fbd76f1f65179c0494aefc97c82a9e9" title="Given a list of lists of types ListOfLists and a Metafunction Class Fun, construct a new list by call...">meta::zip_with</a></code> examples </p>
</blockquote>
<p>Other typical operations on type lists include iteration, reductions, finding elements, removing duplicates:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacemeta_1_1lazy.html">meta::lazy</a>;</div>
<div class="line">    <span class="keyword">using</span> l = <a class="code" href="structmeta_1_1list.html">meta::list&lt;short, int, long, long long, float, float&gt;</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> size_of_largest_type =</div>
<div class="line">        <a class="code" href="group__transformation.html#ga8c8710c36ab2d46f85552be596be9c74">meta::fold&lt;l, meta::size_t&lt;0&gt;</a>, <a class="code" href="group__metafunction.html#ga9723a7a839e8753b28083e01db1d2b4d">meta::lambda&lt;_a, _b, max&lt;_a, sizeof_&lt;_b&gt;</a>&gt;&gt;&gt;;</div>
<div class="line">    static_assert(size_of_largest_type{} == <a class="code" href="group__metafunction.html#gac14214187fc011fb2c0f719a034bb730">meta::sizeof_&lt;long long&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> largest_type =</div>
<div class="line">        <a class="code" href="group__transformation.html#ga8c8710c36ab2d46f85552be596be9c74">meta::fold</a>&lt;l, <a class="code" href="structmeta_1_1nil__.html">meta::nil_</a>,</div>
<div class="line">                   <a class="code" href="group__metafunction.html#ga9723a7a839e8753b28083e01db1d2b4d">meta::lambda&lt;_a, _b, if_&lt;greater&lt;sizeof_&lt;_a&gt;</a>, <a class="code" href="structmeta_1_1defer.html">sizeof_&lt;_b&gt;</a>&gt;, _a, _b&gt;&gt;&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;largest_type, long long&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> first_type_larger_than_int =</div>
<div class="line">        <a class="code" href="group__list.html#ga06eaecac4a0a2b60029b30bb2e4bd878">meta::front&lt;meta::find_if&lt;l, meta::lambda&lt;_a, greater&lt;sizeof_&lt;_a&gt;</a>, <a class="code" href="structmeta_1_1defer.html">sizeof_&lt;int&gt;</a>&gt;&gt;&gt;&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;first_type_larger_than_int, long&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> unique_types = <a class="code" href="group__transformation.html#ga1fda5022e85a5352ee4a2bf907db080c">meta::unique&lt;l&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;unique_types, <a class="code" href="structmeta_1_1list.html">meta::list&lt;short, int, long, long long, float&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To convert other type sequences into a <code><a class="el" href="structmeta_1_1list.html" title="A list of types. ">meta::list</a></code>, the utility metafunction <code><a class="el" href="group__list.html#ga67915953c4206ed93a30d23af7d9a5d4" title="Turn a type into an instance of meta::list in a way determined by meta::apply_list. ">meta::as_list</a>&lt;Sequence&gt;</code> is provided. For example:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> t = std::tuple&lt;int, double, float&gt;;</div>
<div class="line">    <span class="keyword">using</span> l = <a class="code" href="group__list.html#ga67915953c4206ed93a30d23af7d9a5d4">meta::as_list&lt;t&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;l, <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> i = <a class="code" href="group__integral.html#ga089cefaa86388a63a2377fbc78409352">meta::make_index_sequence&lt;3&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> il = <a class="code" href="group__list.html#ga67915953c4206ed93a30d23af7d9a5d4">meta::as_list&lt;i&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;il, <a class="code" href="structmeta_1_1list.html">meta::list</a>&lt;std::integral_constant&lt;std::size_t, 0&gt;,</div>
<div class="line">                                              std::integral_constant&lt;std::size_t, 1&gt;,</div>
<div class="line">                                              std::integral_constant&lt;std::size_t, 2&gt;&gt;&gt;{},</div>
<div class="line">                  <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To use meta with your own data types you can specialize the <code><a class="el" href="namespacemeta_1_1extension.html" title="Extend meta with your own datatypes. ">meta::extension</a>:apply_list</code> metafunction for your own data type. For example, to use meta with C++14 <code>std::integer_sequence</code>, you can:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacemeta.html">meta</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">namespace </span>extension</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T, T... Is&gt;</div>
<div class="line">        <span class="keyword">struct </span><a class="code" href="group__invocation.html#gacfb661d4797be0dad426c5f9998509f9">apply_list</a>&lt;F, <a class="code" href="namespacestd.html">std</a>::integer_sequence&lt;T, Is...&gt;&gt;</div>
<div class="line">            : <a class="code" href="group__lazy__invocation.html#gaff71005f5cbe42f7471af8426d78134c">lazy::apply</a>&lt;F, std::integral_constant&lt;T, Is&gt;...&gt;</div>
<div class="line">        {</div>
<div class="line">        };</div>
<div class="line">    } <span class="comment">// namespace extension</span></div>
<div class="line">} <span class="comment">// namespace meta</span></div>
</div><!-- fragment --> <h3>Overview</h3>
<p>This is a brief overview of the functionality in meta:</p>
<ul>
<li>Metafunction: <code><a class="el" href="group__invocation.html#gaef73a6f4def71032bfa868bc2b27544c" title="&quot;Evaluate&quot; the metafunction T by returning the nested T::type alias. ">meta::eval</a></code>, <code><a class="el" href="group__invocation.html#ga50f4cd4b5ba11a1c3c6e09e5b7f7e4ec" title="Evaluate the Metafunction Class F with the arguments Args. ">meta::apply</a></code>, <code><a class="el" href="structmeta_1_1defer.html" title="A wrapper that defers the instantiation of a template in a lambda expression. ">meta::defer</a></code>, <code><a class="el" href="structmeta_1_1quote.html" title="Turn a class template or alias template C into a Metafunction Class. ">meta::quote</a></code>, <code><a class="el" href="structmeta_1_1compose.html" title="Compose the Metafunction Classes Fs in the parameter pack Ts. ">meta::compose</a></code>, <code><a class="el" href="structmeta_1_1bind__front.html" title="A Metafunction Class that partially applies the Metafunction Class F by binding the arguments Ts to t...">meta::bind_front</a></code>, <code><a class="el" href="structmeta_1_1bind__back.html" title="A Metafunction Class that partially applies the Metafunction Class F by binding the arguments Us to t...">meta::bind_back</a></code>, <code><a class="el" href="group__composition.html#ga208c20d6d38a9efe6230dd116bd20758" title="A Metafunction Class that takes a bunch of arguments, bundles them into a type list, and then calls the Metafunction Class F with the type list Q. ">meta::curry</a></code>, <code><a class="el" href="group__composition.html#ga6aea9f402682b7b31ec467a96c3ee4cd" title="A Metafunction Class that takes a type list, unpacks the types, and then calls the Metafunction Class...">meta::uncurry</a></code>, <code><a class="el" href="group__metafunction.html#ga9723a7a839e8753b28083e01db1d2b4d" title="For creating anonymous Metafunction Classes. ">meta::lambda</a></code>.</li>
<li>List: <code><a class="el" href="structmeta_1_1list.html" title="A list of types. ">meta::list</a></code>, <code><a class="el" href="group__list.html#ga06eaecac4a0a2b60029b30bb2e4bd878" title="Return the first element in meta::list List. ">meta::front</a></code>, <code><a class="el" href="group__list.html#ga3f13cb6243f06ffb4b509709e85ffaf9" title="Return the last element in meta::list List. ">meta::back</a></code>, <code>meta::list_element</code>, <code>meta::list_element_c</code>. <code><a class="el" href="group__list.html#gada7280d87ece1a3dc6b203ee0e86e71c" title="An Boolean integral constant wrapper around true if List is an empty type list; false, otherwise. ">meta::empty</a></code>, <code><a class="el" href="group__list.html#gad3a42ffe5a3789ca77b32080b1ae6f33" title="An integral constant wrapper that is the size of the meta::list List. ">meta::size</a></code>.</li>
<li>Logical: <code><a class="el" href="group__logical.html#ga56a131a7be37d706a5f85f5fcab6d5f2" title="Select one type or another depending on a compile-time Boolean. ">meta::if_</a></code>, <code><a class="el" href="group__logical.html#ga336f87c76347f4d2df7787321fd7d2e3" title="Logically and together all the integral constant-wrapped Boolean parameters, with short-circuiting...">meta::and_</a></code>, <code><a class="el" href="group__logical.html#ga9ca5af65887ca2392d48c549b5ce0951" title="Logically or together all the integral constant-wrapped Boolean parameters, with short-circuiting. ">meta::or_</a></code>, <code><a class="el" href="group__logical.html#ga9574392c8ceafc6a6007163877452daa" title="Logically negate the integral constant-wrapped Boolean parameter. ">meta::not_</a></code>.</li>
<li>Query and search: <code><a class="el" href="group__query.html#gacba0b56400aa8e5deb1109cf9ef44470" title="A Boolean integral constant wrapper around true if apply<F, A>::value is true for all elements A in m...">meta::all_of</a></code>, <code><a class="el" href="group__query.html#ga0bc0c7247dd48f30550b6337e50425af" title="A Boolean integral constant wrapper around true if apply<F, A>::value is true for any element A in me...">meta::any_of</a></code>, <code><a class="el" href="group__query.html#ga529623061fd585759121bbb71105cd6e" title="A Boolean integral constant wrapper around true if apply<F, A>::value is false for all elements A in ...">meta::none_of</a></code>, <code><a class="el" href="group__query.html#gaae3127627a636a91b39e8d645bd8ca70" title="A Boolean integral constant wrapper around true if there is at least one occurrence of T in List...">meta::in</a></code>, <code><a class="el" href="group__query.html#gab50c373191bbcc21a184517d19ec7953" title="Return the tail of the list List starting at the first occurrence of T, if any such element exists; t...">meta::find</a></code>, <code><a class="el" href="group__query.html#ga4f63b6eebba4bdc8d8b2c0206772e22a" title="Return the tail of the list List starting at the last occurrence of T, if any such element exists; th...">meta::reverse_find</a></code>, <code><a class="el" href="group__query.html#ga125a7f8cda7983264fac888081fd4209" title="Return the tail of the list List starting at the first element A such that apply<Fun, A>::value is true, if any such element exists; the empty list, otherwise. ">meta::find_if</a></code>, <code><a class="el" href="group__query.html#ga162ad3f0eb0c95061e062a5db64aadc3" title="Return the tail of the list List starting at the last element A such that apply<Fun, A>::value is true, if any such element exists; the empty list, otherwise. ">meta::reverse_find_if</a></code>.</li>
<li>Transformation: <code><a class="el" href="group__transformation.html#ga2def322f3d51a997386fd8ee2520da97" title="Concatenates several lists into a single list. ">meta::concat</a></code>, <code><a class="el" href="group__transformation.html#ga9ff16525d8cace82e7cdcce09854ca1c" title="Joins a list of lists into a single list. ">meta::join</a></code>, <code><a class="el" href="group__transformation.html#ga6eb038779ea181d1831304d4dcc5677c" title="Given a list of lists of types ListOfLists, construct a new list by grouping the elements from the li...">meta::zip</a></code>, <code><a class="el" href="group__transformation.html#ga2fbd76f1f65179c0494aefc97c82a9e9" title="Given a list of lists of types ListOfLists and a Metafunction Class Fun, construct a new list by call...">meta::zip_with</a></code>, <code><a class="el" href="group__list.html#ga67915953c4206ed93a30d23af7d9a5d4" title="Turn a type into an instance of meta::list in a way determined by meta::apply_list. ">meta::as_list</a></code>, <code><a class="el" href="group__transformation.html#gadea57dff3ae7e9bf1d0fee072654a55f" title="Return a new meta::list by adding the element T to the front of List. ">meta::push_front</a></code>, <code><a class="el" href="group__transformation.html#ga67c3440428c1005a426b67d02a1d73ea" title="Return a new meta::list by adding the element T to the back of List. ">meta::push_back</a></code>, <code><a class="el" href="group__transformation.html#ga2cc15bf74fb712d393ebe57240e770e7" title="Return a new meta::list by removing the first N elements from List. ">meta::drop</a></code>, <code><a class="el" href="group__transformation.html#ga9898b420663fa75e339e77beed853c9c" title="Return a new meta::list by removing the first N elements from List. ">meta::drop_c</a></code>, <code><a class="el" href="group__transformation.html#ga0a9f17db82fc2e4835d2a5424e46d165" title="Return a new meta::list by removing the first element from the front of List. ">meta::pop_front</a></code>, <code><a class="el" href="group__transformation.html#ga8c8710c36ab2d46f85552be596be9c74" title="Return a new meta::list constructed by doing a left fold of the list List using binary Metafunction C...">meta::fold</a></code>, <code><a class="el" href="group__transformation.html#gae9715490bc3a3cf82deed74fb667acae" title="Return a new meta::list constructed by doing a right fold of the list List using binary Metafunction ...">meta::reverse_fold</a></code>, <code><a class="el" href="group__transformation.html#ga9ca974f63ad4bb43802cf68d3c83bb8f" title="An alias for meta::fold. ">meta::accumulate</a></code>, <code><a class="el" href="group__transformation.html#ga1fda5022e85a5352ee4a2bf907db080c" title="Return a new meta::list where all duplicate elements have been removed. ">meta::unique</a></code>, <code><a class="el" href="group__transformation.html#gae4e577387c3f09f0e77df438df5bac8c" title="Return a new meta::list where all instances of type T have been replaced with U. ">meta::replace</a></code>, <code><a class="el" href="group__transformation.html#ga32865e04445de81579ebf84670c54894" title="Return a new meta::list where all elements A of the list List for which apply<C,A>::value is true hav...">meta::replace_if</a></code>, <code><a class="el" href="group__transformation.html#gab6d4b077c3db143225573a021677108f" title="Returns a new meta::list where only those elements of List A that satisfy the Metafunction Class Pred...">meta::filter</a></code>, <code><a class="el" href="group__transformation.html#gab1a5e409dea037379a12819c3bca436f" title="Return a new meta::list constructed by transforming all the elements in List with the unary Metafunci...">meta::transform</a></code>, <code><a class="el" href="group__transformation.html#gac34fe4c73001dab0bfa9604cb87161fc" title="Return a new meta::list by reversing the elements in the list List. ">meta::reverse</a></code>, <code><a class="el" href="group__transformation.html#gaf35ecbb4ab9fa35cdb62fc0d8c06bba5" title="Given a list of lists ListOfLists, return a new list of lists that is the Cartesian Product...">meta::cartesian_product</a></code>.</li>
<li>Math: <code><a class="el" href="group__math.html#gab5e2f54a307613cfd97223ca45fb2419" title="An integral constant wrapper around the result of adding the two wrapped integers T::type::value and ...">meta::plus</a></code> , <code><a class="el" href="group__math.html#ga5738a7d892d9bf6f281f87b556057ecb" title="An integral constant wrapper around the result of subtracting the two wrapped integers T::type::value...">meta::minus</a></code>, <code><a class="el" href="group__math.html#ga7002487e702ddd681507f5ab8b6ee0d4" title="An integral constant wrapper around the result of multiplying the two wrapped integers T::type::value...">meta::multiplies</a></code>, <code><a class="el" href="group__math.html#ga4d16896fb397ec3ded21808fc2749b41" title="An integral constant wrapper around the result of dividing the two wrapped integers T::type::value an...">meta::divides</a></code>, <code><a class="el" href="group__math.html#ga9f3a3adf2556161e23d0b181d075498a" title="An integral constant wrapper around the remainder of dividing the two wrapped integers T::type::value...">meta::negate</a></code>, <code><a class="el" href="group__math.html#gadb0adcf6123000b8aabccca5a6090289" title="An integral constant wrapper around the remainder of dividing the two wrapped integers T::type::value...">meta::modulus</a></code>, <code><a class="el" href="group__math.html#gadccc21f4cad9bc9971798006950c48a2" title="A Boolean integral constant wrapper around the result of comparing T::type::value and U::type::value ...">meta::equal_to</a></code>, <code><a class="el" href="group__math.html#ga0ac5f5c29d6eacedec33733d5e224ec0" title="A Boolean integral constant wrapper around the result of comparing T::type::value and U::type::value ...">meta::not_equal_to</a></code>, <code><a class="el" href="group__math.html#gaf4b1427cc9c4040ffca9845c068621ed" title="A Boolean integral constant wrapper around true if T::type::value is greater than U::type::value; fal...">meta::greater</a></code>, <code><a class="el" href="group__math.html#gabdb640343287440ca84ce0217faf7741" title="A Boolean integral constant wrapper around true if T::type::value is less than U::type::value; false...">meta::less</a></code>, <code><a class="el" href="group__math.html#ga03eb74e40109672a931e14505c90f40d" title="A Boolean integral constant wrapper around true if T::type::value is greater than or equal to U::type...">meta::greater_equal</a></code>, <code><a class="el" href="group__math.html#gab2b03f0bfd42cbb237831b6aaf2f0ef5" title="A Boolean integral constant wrapper around true if T::type::value is less than or equal to U::type::v...">meta::less_equal</a></code>, <code><a class="el" href="group__math.html#gadb33906bcf029b1a272a7acc4c2b1e58" title="An integral constant wrapper around the result of bitwise-and&#39;ing the two wrapped integers T::type::v...">meta::bit_and</a></code>, <code><a class="el" href="group__math.html#ga5ae6f56a9b7c7f29593cd48812ce09ca" title="An integral constant wrapper around the result of bitwise-or&#39;ing the two wrapped integers T::type::va...">meta::bit_or</a></code>, <code><a class="el" href="group__math.html#ga1bc30e36ab8d456a9907e1f16cf21976" title="An integral constant wrapper around the result of bitwise-exclusive-or&#39;ing the two wrapped integers T...">meta::bit_xor</a></code>, <code><a class="el" href="group__math.html#ga7123fd4e34449e1357f8230c1c142f58" title="An integral constant wrapper around the result of bitwise-complimenting the wrapped integer T::type::...">meta::bit_not</a></code>, <code><a class="el" href="group__math.html#gaec747fb8e9057b54352be750a67f532b" title="An integral constant wrapper around the minimum of T::type::value and U::type::value. ">meta::min</a></code>, <code><a class="el" href="group__math.html#gad65ae3f3f053c6f7f2757534fa51c9d0" title="An integral constant wrapper around the maximum of T::type::value and U::type::value. ">meta::max</a></code>.</li>
<li>Run time: <code><a class="el" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03" title="for_each(List, UnaryFunction) calls the UnaryFunction for each argument in the List. ">meta::for_each</a></code>.</li>
</ul>
<p>See the reference section for more details. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
