<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Meta: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Meta
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">A tiny metaprogramming library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
<p> <em>Meta</em> is a C++11 tiny metaprogramming library developed by <a href="https://github.com/ericniebler">Eric Niebler</a> to facilitate the computation and manipulation of types and lists of types (aka, variadic parameter packs).</p>
<p>It is released under the Boost Software License and it is header only; that is, to compile with meta you just have to:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="meta_8hpp.html">meta/meta.hpp</a>&gt;</span></div>
</div><!-- fragment --> <hr/>
<p>The documentation of <em>Meta</em> is currently scarce. The best resources are the <a href="group__meta.html">Reference</a> and the <a href="examples.html">Examples</a>.</p>
<p>As a motivation and introduction to the library you can read <a href="http://ericniebler.com/2014/11/13/tiny-metaprogramming-library/">Eric's original blog post</a>, but please keep in mind that the library has evolved quite a bit since then. </p><hr/>
<h2>Quick Start</h2>
<p>TODO show some simple uses. Make sure we show what Meta is good for before diving into terminology and esoteric concepts.</p>
<h2>Tutorial</h2>
<p>The tutorial begins with a brief introduction to traits, aliases, and callables. Then it moves to trait composition and currying. Finally, it covers type list algorithms and algorithms for working on integer sequences.</p>
<p>TODO This feels backwards. Algorithms come first. Everything else is in support of them.</p>
<h3>Traits</h3>
<p><em>Traits</em> are class templates that have a nested type alias called (by convention) <code>type</code>. For example,</p>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    <span class="keyword">struct </span>t</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> type = void;</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">using</span> result = <span class="keyword">typename</span> t&lt;int, double&gt;::type;</div>
<div class="line">    static_assert(std::is_same&lt;result, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> is a trait taking an arbitrary number of types that always "returns" <code>void</code>. There are many familiar examples of traits in the Standard Library; <code>std::remove_reference</code> and <code>std::is_void</code> to name two.</p>
<h2>Aliases</h2>
<p>An <em>alias</em> is a synonym for a type. C++11 introduced alias <em>templates</em>, which are names that refer to a family of types. Alias templates simplify template syntax and smooth out interface differences. Below is an example of an alias template:</p>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    <span class="keyword">using</span> t_t = <span class="keyword">typename</span> t&lt;Args...&gt;::type;</div>
<div class="line">    <span class="keyword">using</span> result = t_t&lt;int, double&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;result, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Notice how <code>t_t&lt;int, double&gt;</code> becomes a synonym for <code>void</code>. The C++14 standard library provides <code>_t</code> alias templates for all the traits in the standard library.</p>
<p><em>Meta</em> provides <code><a class="el" href="group__invocation.html#ga08e2193149605769f6052795ff0a87b1" title="Type alias for T::type. ">meta::_t</a>&lt;T&gt;</code>, which evaluates the trait <code>T</code> by aliasing the nested <code>T::type</code> alias. This allows us to alias the nested <code>type</code> of a trait as follows:</p>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">    <span class="keyword">using</span> t2_t = <a class="code" href="group__invocation.html#ga08e2193149605769f6052795ff0a87b1">meta::_t</a>&lt;t&lt;Args...&gt;&gt;;</div>
<div class="line">    <span class="keyword">using</span> result = t2_t&lt;int, double&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;result, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Alias templates have primacy in Meta. This is different from other metaprogramming libraries you may be familiar with, which make traits (aka metafunctions) the prime abstraction. The rest of this guide uses the term "alias" to mean "alias template".</dd></dl>
<h3>Callables</h3>
<p>A <em>Callable</em> is a kind of alias suitable for higher-order metaprogramming. It is a class (not a template!) with a nested alias called (by convention) <code>invoke</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">struct </span>ac</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">        <span class="keyword">using</span> <a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">invoke</a> = void;</div>
<div class="line">    };</div>
</div><!-- fragment --><p> All of the algorithms that take "functions" as arguments expect Callables instead of raw aliases. <em>Meta</em> provides the <code><a class="el" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc" title="Evaluate the Callable F with the arguments Args. ">meta::invoke</a>&lt;F, Args...&gt;</code> alias that evaluates the Callable <code>F</code> with the arguments <code>Args</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> result = <a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;ac, int, double&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;result, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To turn an ordinary alias into a Callable <em>Meta</em> provides the <code><a class="el" href="structmeta_1_1quote.html" title="Turn a class template or alias template C into a Callable. ">meta::quote</a>&lt;F&gt;</code> trait:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> t_callable0 = <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;t&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> result0 = <a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;t_callable0, int, double&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;result0, t&lt;int, double&gt;&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(std::is_same&lt;<a class="code" href="group__invocation.html#ga08e2193149605769f6052795ff0a87b1">meta::_t&lt;result0&gt;</a>, <span class="keywordtype">void</span>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> t_callable1 = <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;t_t&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> result1 = <a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;t_callable1, int, double&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;result1, void&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Note that in the first case we create a Callable that evaluates to the trait itself, while in the second case we create a Callable that evaluates to the nested <code>type</code> of the trait.</p>
<p>When "quoting" a trait, it is often desirable for the resulting Callable to refer to the nested <code>type</code> instead of the trait itself. For that we can use <code><a class="el" href="group__composition.html#gac6c8e7f22915d3dc4b3d5aff59752f92" title="Turn a trait template C into a Callable. ">meta::quote_trait</a></code>. Consider:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> t_callable0 = <a class="code" href="structmeta_1_1compose.html">meta::quote_trait&lt;std::add_pointer&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> result0 = <a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;t_callable0, int&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;result0, int *&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if __cplusplus &gt; 201103L</span></div>
<div class="line">    <span class="keyword">using</span> t_callable1 = <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;std::add_pointer_t&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> result1 = <a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;t_callable1, int&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;result1, int *&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p> Notice that <code><a class="el" href="structmeta_1_1quote.html" title="Turn a class template or alias template C into a Callable. ">meta::quote</a>&lt;std::add_pointer_t&gt;</code> and <code><a class="el" href="group__composition.html#gac6c8e7f22915d3dc4b3d5aff59752f92" title="Turn a trait template C into a Callable. ">meta::quote_trait</a>&lt;std::add_pointer&gt;</code> mean the same thing.</p>
<dl class="section note"><dt>Note</dt><dd>You may wonder what advantage Callables have over alias templates. A Callable is a <em>type</em> that represents a computation. Much of Meta revolves around types and the computation of types. Sometimes it's desirable to compute a computation, or to use a computation as an argument to another computation. In those cases, it's very handy for computations to themselves be types and not templates.</dd></dl>
<h3>Composition</h3>
<p>Multiple Callables can be composed into a single Callable using <code><a class="el" href="structmeta_1_1compose.html" title="Compose the Callables Fs in the parameter pack Ts. ">meta::compose</a>&lt;F0, F1, ..., FN&gt;</code>, which names a new Callable that performs <code>F0(F1(...(FN(Args...))))</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keyword">using</span> t0 = <a class="code" href="group__invocation.html#ga08e2193149605769f6052795ff0a87b1">meta::_t&lt;std::make_signed&lt;T&gt;</a>&gt;;</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keyword">using</span> t1 = <a class="code" href="group__invocation.html#ga08e2193149605769f6052795ff0a87b1">meta::_t&lt;std::add_const&lt;T&gt;</a>&gt;;</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">    <span class="keyword">using</span> t2 = <a class="code" href="group__invocation.html#ga08e2193149605769f6052795ff0a87b1">meta::_t&lt;std::add_lvalue_reference&lt;T&gt;</a>&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> t = <a class="code" href="structmeta_1_1compose.html">meta::compose&lt;meta::quote&lt;t2&gt;</a>, <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;t1&gt;</a>, <a class="code" href="structmeta_1_1quote.html">meta::quote&lt;t0&gt;</a>&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;<a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;t, unsigned&gt;</a>, <span class="keywordtype">int</span> <span class="keyword">const</span> &amp;&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <h3>Partial function application</h3>
<p>You can turn a Callable expecting <em>N</em> arguments into a Callable expecting <em>N-M</em> arguments by binding <em>M</em> arguments to the front or the back of its argument list. You can use <code><a class="el" href="structmeta_1_1bind__front.html" title="A Callable that partially applies the Callable F by binding the arguments Ts to the front of F...">meta::bind_front</a></code> and <code><a class="el" href="structmeta_1_1bind__back.html" title="A Callable that partially applies the Callable F by binding the arguments Us to the back of F...">meta::bind_back</a></code> for that. Below we create a Callable that tests whether a type is <code>float</code> by reusing the <code>std::is_same</code> trait:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> is_float = <a class="code" href="structmeta_1_1bind__front.html">meta::bind_front&lt;meta::quote&lt;std::is_same&gt;</a>, <span class="keywordtype">float</span>&gt;;</div>
<div class="line">    static_assert(<a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;is_float, float&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(!<a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;is_float, double&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> is_float2 = <a class="code" href="structmeta_1_1bind__back.html">meta::bind_back&lt;meta::quote&lt;std::is_same&gt;</a>, <span class="keywordtype">float</span>&gt;;</div>
<div class="line">    static_assert(<a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;is_float2, float&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    static_assert(!<a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke&lt;is_float2, double&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If <code>std::is_same</code> is a trait, why did we use <code><a class="el" href="structmeta_1_1quote.html" title="Turn a class template or alias template C into a Callable. ">meta::quote</a></code> instead of <code><a class="el" href="group__composition.html#gac6c8e7f22915d3dc4b3d5aff59752f92" title="Turn a trait template C into a Callable. ">meta::quote_trait</a></code>? In this case, it makes no difference. In addition to being a trait, <code>std::is_same&lt;X, Y&gt;</code> inherits from <code>std::integral_constant&lt;bool, true-or-false&gt;</code> so we can construct an instance of <code>std::is_same&lt;X, Y&gt;</code> and test it in a <code>constexr</code> Boolean context.</dd></dl>
<h3>Logical operations</h3>
<p>The traits <code><a class="el" href="group__logical.html#ga6e540c0fb0c8d686d140034c0b31ac44" title="Select one type or another depending on a compile-time Boolean. ">meta::if_</a></code>, <code><a class="el" href="group__logical.html#ga724f3a0fc2262e19d54086d2ddd1bfc2" title="Logically and together all the integral constant-wrapped Boolean parameters, with short-circuiting...">meta::and_</a></code>, <code><a class="el" href="group__logical.html#ga7f33e09ccaa36f32d0f490a1606898bb" title="Logically or together all the integral constant-wrapped Boolean parameters, with short-circuiting. ">meta::or_</a></code>, and <code><a class="el" href="group__logical.html#ga9574392c8ceafc6a6007163877452daa" title="Logically negate the integral constant-wrapped Boolean parameter. ">meta::not_</a></code> cover the basic logical operations with types:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> t0 = <a class="code" href="group__logical.html#ga6e540c0fb0c8d686d140034c0b31ac44">meta::if_&lt;std::is_same&lt;float, double&gt;</a>, <a class="code" href="group__integral.html#ga8cd5c79222ce70365f7469f35ece905a">meta::bool_&lt;true&gt;</a>, <a class="code" href="group__integral.html#ga8cd5c79222ce70365f7469f35ece905a">meta::bool_&lt;false&gt;</a>&gt;;</div>
<div class="line">    static_assert(!t0{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> t1 = <a class="code" href="group__logical.html#ga724f3a0fc2262e19d54086d2ddd1bfc2">meta::and_&lt;meta::bool_&lt;true&gt;</a>, meta::bool_&lt;false&gt;, meta::bool_&lt;true&gt;&gt;;</div>
<div class="line">    static_assert(!t1{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> t2 = <a class="code" href="group__logical.html#ga7f33e09ccaa36f32d0f490a1606898bb">meta::or_&lt;meta::bool_&lt;true&gt;</a>, meta::bool_&lt;false&gt;, meta::bool_&lt;true&gt;&gt;;</div>
<div class="line">    static_assert(t2{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> t3 = <a class="code" href="group__logical.html#ga9574392c8ceafc6a6007163877452daa">meta::not_&lt;t1&gt;</a>;</div>
<div class="line">    static_assert(t3{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <h3>Eager and lazy evaluation</h3>
<blockquote class="doxtable">
<p>TODO aliases are eager, <code><a class="el" href="structmeta_1_1defer.html" title="A wrapper that defers the instantiation of a template C with type parameters Ts in a lambda or let ex...">meta::defer</a></code>, <code><a class="el" href="namespacemeta_1_1lazy.html" title="Lazy versions of meta actions. ">meta::lazy</a></code> namespace. </p>
</blockquote>
<h3>Lambdas</h3>
<p>Lambda functions allow you to define Callables in place:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacemeta_1_1placeholders.html">meta::placeholders</a>;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="group__math.html#gaf4b1427cc9c4040ffca9845c068621ed">greater</a> = <a class="code" href="group__trait.html#gae8c0959d22f1e6e91bd3848d08da1b48">meta::lambda&lt;_a, _b, meta::lazy::less&lt;_b, _a&gt;</a>&gt;;</div>
<div class="line"></div>
<div class="line">    static_assert(<a class="code" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc">meta::invoke</a>&lt;<a class="code" href="group__math.html#gaf4b1427cc9c4040ffca9845c068621ed">greater</a>, <a class="code" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679">meta::size_t&lt;2&gt;</a>, <a class="code" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679">meta::size_t&lt;1&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <h3>Type lists</h3>
<p>A list of types <code>Ts...</code> can be stored in the type <code><a class="el" href="structmeta_1_1list.html" title="A list of types. ">meta::list</a>&lt;Ts...&gt;</code>. It provides a O(1) static member function <code><a class="el" href="structmeta_1_1list.html#a1fc19362369fd9373308b9926beac87d">meta::list::size()</a></code> that returns the size of the list.</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> list = <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float&gt;</a>;</div>
<div class="line">    static_assert(<a class="code" href="group__list.html#gad3a42ffe5a3789ca77b32080b1ae6f33">list::size</a>() == 3, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="group__list.html#gaa3bafa5880d3e11e010b96bcdc1668a2">front</a> = <a class="code" href="group__list.html#gaa3bafa5880d3e11e010b96bcdc1668a2">meta::front&lt;list&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;front, int&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="group__list.html#ga8129daa8249ae40ec7d8dae6434dc2be">back</a> = <a class="code" href="group__list.html#ga8129daa8249ae40ec7d8dae6434dc2be">meta::back&lt;list&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;back, float&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> at_1 = <a class="code" href="group__list.html#gad6e980f0ae3fcf95b6bbe1eb6593519a">meta::at_c&lt;list, 1&gt;</a>;</div>
<div class="line"></div>
<div class="line">    static_assert(std::is_same&lt;at_1, double&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> index_double = <a class="code" href="group__query.html#ga7ac6038da9e16a285180333392f83834">meta::find_index&lt;list, double&gt;</a>;</div>
<div class="line">    static_assert(index_double{} == 1, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> index_char = <a class="code" href="group__query.html#ga7ac6038da9e16a285180333392f83834">meta::find_index&lt;list, char&gt;</a>;</div>
<div class="line">    static_assert(index_char{} == <a class="code" href="group__list.html#gac6b96d77cd4223043591fe6e5819ecf8">meta::npos</a>(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    static_assert(!<a class="code" href="group__list.html#gada7280d87ece1a3dc6b203ee0e86e71c">meta::empty&lt;list&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> As you can see, the <code><a class="el" href="group__list.html#gaa3bafa5880d3e11e010b96bcdc1668a2" title="Return the first element in meta::list List. ">meta::front</a>&lt;List&gt;</code>, <code><a class="el" href="group__list.html#ga8129daa8249ae40ec7d8dae6434dc2be" title="Return the last element in meta::list List. ">meta::back</a>&lt;List&gt;</code>, and <code><a class="el" href="group__list.html#gad6e980f0ae3fcf95b6bbe1eb6593519a" title="Return the N th element in the meta::list List. ">meta::at_c</a>&lt;List, std::size_t&gt;</code> aliases provide access to the elements of the list. The <code><a class="el" href="group__list.html#gada7280d87ece1a3dc6b203ee0e86e71c" title="An Boolean integral constant wrapper around true if List is an empty type list; false, otherwise. ">meta::empty</a>&lt;List&gt;</code> alias is <code>std::true_type</code> if the list is empty. The <code><a class="el" href="group__list.html#gae9c7af0616cb28f655628c209899d45e" title="Return the N th element in the meta::list List. ">meta::at</a>&lt;List, <a class="el" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679" title="An integral constant wrapper for std::size_t. ">meta::size_t</a>&lt;N&gt;&gt;</code> alias differs from <code><a class="el" href="group__list.html#gad6e980f0ae3fcf95b6bbe1eb6593519a" title="Return the N th element in the meta::list List. ">meta::at_c</a></code> in that it takes a <code><a class="el" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679" title="An integral constant wrapper for std::size_t. ">meta::size_t</a>&lt;N&gt;</code> (<code>std::integral_constant&lt;std::size_t, N&gt;</code>) instead of an integer:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> i = <a class="code" href="group__integral.html#ga92ba0e8ad97a32c34cec51aa6d4f8679">meta::size_t&lt;1&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> at_1 = <a class="code" href="group__list.html#gae9c7af0616cb28f655628c209899d45e">meta::at&lt;list, i&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;at_1, double&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> You can add and remove elements from a list by using the transformation algorithms:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> l2 = <a class="code" href="group__transformation.html#gabb41fa596a6cec8354991b02baa25e4e">meta::push_front&lt;list, char&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;l2, <a class="code" href="structmeta_1_1list.html">meta::list&lt;char, int, double, float&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> l3 = <a class="code" href="group__transformation.html#gad9ca46fd838d2151d79ebba86c5bd99f">meta::pop_front&lt;l2&gt;</a>; <span class="comment">// equivalent to meta::drop&lt;l2, 1&gt;;</span></div>
<div class="line">    static_assert(std::is_same&lt;l3, list&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> l4 = <a class="code" href="group__transformation.html#gaf3767f6183c02a699020096f58703f39">meta::push_back&lt;list, char&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;l4, <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float, char&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> l5 = <a class="code" href="group__transformation.html#ga5ba487579193bdb7232b81d85ce601e8">meta::drop_c&lt;l4, 3&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;l5, <a class="code" href="structmeta_1_1list.html">meta::list&lt;char&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> You can concatenate, flatten, and zip multiple lists using <code><a class="el" href="group__transformation.html#ga37b909e738292271af463b8d2b56d682" title="Concatenates several lists into a single list. ">meta::concat</a>&lt;Lists...&gt;</code>, <code><a class="el" href="group__transformation.html#gae8b919ad4c2cfe9b0fc7549cedae5e37" title="Joins a list of lists into a single list. ">meta::join</a>&lt;ListOfLists&gt;</code>, and <code><a class="el" href="group__transformation.html#ga559fdaee384c3d297b86ab217b26f601" title="Given a list of lists of types ListOfLists, construct a new list by grouping the elements from the li...">meta::zip</a>&lt;ListOfLists&gt;</code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> list0 = <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> list1 = <a class="code" href="structmeta_1_1list.html">meta::list&lt;&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> list2 = <a class="code" href="structmeta_1_1list.html">meta::list&lt;float, char&gt;</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> concatenated = <a class="code" href="group__transformation.html#ga37b909e738292271af463b8d2b56d682">meta::concat&lt;list0, list1, list2&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;concatenated, <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float, char&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> list_of_lists = <a class="code" href="structmeta_1_1list.html">meta::list&lt;list0, list1, list2&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> flattened = <a class="code" href="group__transformation.html#gae8b919ad4c2cfe9b0fc7549cedae5e37">meta::join&lt;list_of_lists&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;flattened, <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float, char&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> list_of_lists_of_same_length = <a class="code" href="structmeta_1_1list.html">meta::list&lt;list0, list2&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> zipped = <a class="code" href="group__transformation.html#ga559fdaee384c3d297b86ab217b26f601">meta::zip&lt;list_of_lists_of_same_length&gt;</a>;</div>
<div class="line">    static_assert(</div>
<div class="line">        std::is_same&lt;zipped, <a class="code" href="structmeta_1_1list.html">meta::list</a>&lt;<a class="code" href="structmeta_1_1list.html">meta::list&lt;int, float&gt;</a>, <a class="code" href="structmeta_1_1list.html">meta::list&lt;double, char&gt;</a>&gt;&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>TODO: <code><a class="el" href="group__transformation.html#gaeef9e5eb7abea34663e2aa0f8e0c5fa1" title="Given a list of lists of types ListOfLists and a Callable Fun, construct a new list by calling Fun wi...">meta::zip_with</a></code> examples </p>
</blockquote>
<p>Other typical operations on type lists include iteration, reductions, finding elements, removing duplicates:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacemeta_1_1lazy.html">meta::lazy</a>;</div>
<div class="line">    <span class="keyword">using</span> l = <a class="code" href="structmeta_1_1list.html">meta::list&lt;char, int, long, long long, float, float&gt;</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> size_of_largest_type =</div>
<div class="line">        <a class="code" href="group__transformation.html#ga7ffec902d2cc7f3ff4517a4fb74e8561">meta::fold&lt;l, meta::size_t&lt;0&gt;</a>, <a class="code" href="group__trait.html#gae8c0959d22f1e6e91bd3848d08da1b48">meta::lambda&lt;_a, _b, max&lt;_a, sizeof_&lt;_b&gt;</a>&gt;&gt;&gt;;</div>
<div class="line">    static_assert(size_of_largest_type{} == <a class="code" href="group__trait.html#gac14214187fc011fb2c0f719a034bb730">meta::sizeof_&lt;long long&gt;</a>{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> largest_type =</div>
<div class="line">        <a class="code" href="group__transformation.html#ga7ffec902d2cc7f3ff4517a4fb74e8561">meta::fold</a>&lt;l, <a class="code" href="structmeta_1_1nil__.html">meta::nil_</a>,</div>
<div class="line">                   <a class="code" href="group__trait.html#gae8c0959d22f1e6e91bd3848d08da1b48">meta::lambda&lt;_a, _b, if_&lt;greater&lt;sizeof_&lt;_a&gt;</a>, <a class="code" href="structmeta_1_1defer.html">sizeof_&lt;_b&gt;</a>&gt;, _a, _b&gt;&gt;&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;largest_type, long long&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> first_type_larger_than_char =</div>
<div class="line">        <a class="code" href="group__list.html#gaa3bafa5880d3e11e010b96bcdc1668a2">meta::front&lt;meta::find_if&lt;l, meta::lambda&lt;_a, greater&lt;sizeof_&lt;_a&gt;</a>, <a class="code" href="structmeta_1_1defer.html">sizeof_&lt;char&gt;</a>&gt;&gt;&gt;&gt;;</div>
<div class="line">    static_assert(std::is_same&lt;first_type_larger_than_char, int&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> unique_types = <a class="code" href="group__transformation.html#gadf83711e56c6bc24311aa68b338cac7d">meta::unique&lt;l&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;unique_types, <a class="code" href="structmeta_1_1list.html">meta::list&lt;char, int, long, long long, float&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To convert other type sequences into a <code><a class="el" href="structmeta_1_1list.html" title="A list of types. ">meta::list</a></code>, the utility trait <code><a class="el" href="group__list.html#ga888ad156a2ffe515eacfdacd96a1b110" title="Turn a type into an instance of meta::list in a way determined by meta::invoke. ">meta::as_list</a>&lt;Sequence&gt;</code> is provided. For example:</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> t = std::tuple&lt;int, double, float&gt;;</div>
<div class="line">    <span class="keyword">using</span> l = <a class="code" href="group__list.html#ga888ad156a2ffe515eacfdacd96a1b110">meta::as_list&lt;t&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;l, <a class="code" href="structmeta_1_1list.html">meta::list&lt;int, double, float&gt;</a>&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> i = <a class="code" href="group__integral.html#ga089cefaa86388a63a2377fbc78409352">meta::make_index_sequence&lt;3&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> il = <a class="code" href="group__list.html#ga888ad156a2ffe515eacfdacd96a1b110">meta::as_list&lt;i&gt;</a>;</div>
<div class="line">    static_assert(std::is_same&lt;il, <a class="code" href="structmeta_1_1list.html">meta::list</a>&lt;std::integral_constant&lt;std::size_t, 0&gt;,</div>
<div class="line">                                              std::integral_constant&lt;std::size_t, 1&gt;,</div>
<div class="line">                                              std::integral_constant&lt;std::size_t, 2&gt;&gt;&gt;{},</div>
<div class="line">                  <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To use meta with your own data types you can specialize the <code><a class="el" href="structmeta_1_1extension_1_1apply.html" title="A trait that unpacks the types in the type list List into the Callable F. ">meta::extension::apply</a></code> trait for your own data type. For example, to use meta with C++14 <code>std::integer_sequence</code>, you can:</p>
<div class="fragment"></div><!-- fragment --> <h3>Overview</h3>
<p>This is a brief overview of the functionality in meta:</p>
<ul>
<li>Trait: <code><a class="el" href="group__invocation.html#ga08e2193149605769f6052795ff0a87b1" title="Type alias for T::type. ">meta::_t</a></code>, <code><a class="el" href="group__invocation.html#ga63ad9a7984ab9ece32f80a3d065d1729" title="Variable alias for T::type::value. ">meta::_v</a></code>, <code><a class="el" href="group__invocation.html#gaa20b4002ec6b258dec0b11affe7d9cdc" title="Evaluate the Callable F with the arguments Args. ">meta::invoke</a></code>, <code><a class="el" href="structmeta_1_1defer.html" title="A wrapper that defers the instantiation of a template C with type parameters Ts in a lambda or let ex...">meta::defer</a></code>, <code><a class="el" href="structmeta_1_1quote.html" title="Turn a class template or alias template C into a Callable. ">meta::quote</a></code>, <code><a class="el" href="group__composition.html#gac6c8e7f22915d3dc4b3d5aff59752f92" title="Turn a trait template C into a Callable. ">meta::quote_trait</a></code>, <code><a class="el" href="structmeta_1_1id.html" title="A trait that always returns its argument T. Also, a Callable that always returns T. ">meta::id</a></code>, <code><a class="el" href="structmeta_1_1compose.html" title="Compose the Callables Fs in the parameter pack Ts. ">meta::compose</a></code>, <code><a class="el" href="structmeta_1_1bind__front.html" title="A Callable that partially applies the Callable F by binding the arguments Ts to the front of F...">meta::bind_front</a></code>, <code><a class="el" href="structmeta_1_1bind__back.html" title="A Callable that partially applies the Callable F by binding the arguments Us to the back of F...">meta::bind_back</a></code>, <code><a class="el" href="group__composition.html#ga208c20d6d38a9efe6230dd116bd20758" title="A Callable that takes a bunch of arguments, bundles them into a type list, and then calls the Callabl...">meta::curry</a></code>, <code><a class="el" href="group__composition.html#ga28038544178439e161d464466adc7f62" title="A Callable that takes a type list, unpacks the types, and then calls the Callable F with the types...">meta::uncurry</a></code>, <code><a class="el" href="group__trait.html#gae8c0959d22f1e6e91bd3848d08da1b48" title="For creating anonymous Callables. ">meta::lambda</a></code>, <code><a class="el" href="group__trait.html#ga029bb5c0d37db028d405490b0d77f28f" title="A lexically scoped expression with local variables. ">meta::let</a></code>, <code><a class="el" href="group__invocation.html#ga3f3ec323be1f393bdc77ff10de87e3d1" title="Applies the Callable C using the types in the type list List as arguments. ">meta::apply</a></code>.</li>
<li>List: <code><a class="el" href="structmeta_1_1list.html" title="A list of types. ">meta::list</a></code>, <code><a class="el" href="group__list.html#gaa3bafa5880d3e11e010b96bcdc1668a2" title="Return the first element in meta::list List. ">meta::front</a></code>, <code><a class="el" href="group__list.html#ga8129daa8249ae40ec7d8dae6434dc2be" title="Return the last element in meta::list List. ">meta::back</a></code>, <code><a class="el" href="group__list.html#gae9c7af0616cb28f655628c209899d45e" title="Return the N th element in the meta::list List. ">meta::at</a></code>, <code><a class="el" href="group__list.html#gad6e980f0ae3fcf95b6bbe1eb6593519a" title="Return the N th element in the meta::list List. ">meta::at_c</a></code>. <code><a class="el" href="group__list.html#gada7280d87ece1a3dc6b203ee0e86e71c" title="An Boolean integral constant wrapper around true if List is an empty type list; false, otherwise. ">meta::empty</a></code>, <code><a class="el" href="group__list.html#gad3a42ffe5a3789ca77b32080b1ae6f33" title="An integral constant wrapper that is the size of the meta::list List. ">meta::size</a></code>.</li>
<li>Logical: <code><a class="el" href="group__logical.html#ga6e540c0fb0c8d686d140034c0b31ac44" title="Select one type or another depending on a compile-time Boolean. ">meta::if_</a></code>, <code><a class="el" href="group__logical.html#ga724f3a0fc2262e19d54086d2ddd1bfc2" title="Logically and together all the integral constant-wrapped Boolean parameters, with short-circuiting...">meta::and_</a></code>, <code><a class="el" href="group__logical.html#ga7f33e09ccaa36f32d0f490a1606898bb" title="Logically or together all the integral constant-wrapped Boolean parameters, with short-circuiting. ">meta::or_</a></code>, <code><a class="el" href="group__logical.html#ga9574392c8ceafc6a6007163877452daa" title="Logically negate the integral constant-wrapped Boolean parameter. ">meta::not_</a></code>.</li>
<li>Query and search: <code><a class="el" href="group__query.html#ga58b364cd1edf3522f0572f5c978cedf3" title="A Boolean integral constant wrapper around true if invoke<F, A>::value is true for all elements A in ...">meta::all_of</a></code>, <code><a class="el" href="group__query.html#ga0bc0c7247dd48f30550b6337e50425af" title="A Boolean integral constant wrapper around true if invoke<F, A>::value is true for any element A in m...">meta::any_of</a></code>, <code><a class="el" href="group__query.html#ga529623061fd585759121bbb71105cd6e" title="A Boolean integral constant wrapper around true if invoke<F, A>::value is false for all elements A in...">meta::none_of</a></code>, <code><a class="el" href="group__query.html#gaae3127627a636a91b39e8d645bd8ca70" title="A Boolean integral constant wrapper around true if there is at least one occurrence of T in List...">meta::in</a></code>, <code><a class="el" href="group__query.html#ga5aee6ad93044a99cedf0ef3ee1999ce2" title="Return the tail of the list List starting at the first occurrence of T, if any such element exists; t...">meta::find</a></code>, <code><a class="el" href="group__query.html#ga8b0476b7b23543ec7dc59cb7339c96ff" title="Return the tail of the list List starting at the last occurrence of T, if any such element exists; th...">meta::reverse_find</a></code>, <code><a class="el" href="group__query.html#gaf802488886595689f3289d6530ee428c" title="Return the tail of the list List starting at the first element A such that invoke<Fun, A>::value is true, if any such element exists; the empty list, otherwise. ">meta::find_if</a></code>, <code><a class="el" href="group__query.html#ga7da94d03c36e47456df5e553afa99a82" title="Return the tail of the list List starting at the last element A such that invoke<Fun, A>::value is true, if any such element exists; the empty list, otherwise. ">meta::reverse_find_if</a></code>, <code>meta::cout</code>.</li>
<li>Transformation: <code><a class="el" href="group__transformation.html#ga37b909e738292271af463b8d2b56d682" title="Concatenates several lists into a single list. ">meta::concat</a></code>, <code><a class="el" href="group__transformation.html#gae8b919ad4c2cfe9b0fc7549cedae5e37" title="Joins a list of lists into a single list. ">meta::join</a></code>, <code><a class="el" href="group__transformation.html#ga559fdaee384c3d297b86ab217b26f601" title="Given a list of lists of types ListOfLists, construct a new list by grouping the elements from the li...">meta::zip</a></code>, <code><a class="el" href="group__transformation.html#gaeef9e5eb7abea34663e2aa0f8e0c5fa1" title="Given a list of lists of types ListOfLists and a Callable Fun, construct a new list by calling Fun wi...">meta::zip_with</a></code>, <code><a class="el" href="group__list.html#ga888ad156a2ffe515eacfdacd96a1b110" title="Turn a type into an instance of meta::list in a way determined by meta::invoke. ">meta::as_list</a></code>, <code><a class="el" href="group__transformation.html#gabb41fa596a6cec8354991b02baa25e4e" title="Return a new meta::list by adding the element T to the front of List. ">meta::push_front</a></code>, <code><a class="el" href="group__transformation.html#gaf3767f6183c02a699020096f58703f39" title="Return a new meta::list by adding the element T to the back of List. ">meta::push_back</a></code>, <code><a class="el" href="group__transformation.html#ga012d67e9ade36bb4d195610bf16f4425" title="Return a new meta::list by removing the first N elements from List. ">meta::drop</a></code>, <code><a class="el" href="group__transformation.html#ga5ba487579193bdb7232b81d85ce601e8" title="Return a new meta::list by removing the first N elements from List. ">meta::drop_c</a></code>, <code><a class="el" href="group__transformation.html#gad9ca46fd838d2151d79ebba86c5bd99f" title="Return a new meta::list by removing the first element from the front of List. ">meta::pop_front</a></code>, <code><a class="el" href="group__transformation.html#ga7ffec902d2cc7f3ff4517a4fb74e8561" title="Return a new meta::list constructed by doing a left fold of the list List using binary Callable Fun a...">meta::fold</a></code>, <code><a class="el" href="group__transformation.html#gaf5fc1db016cf4e512d7c85311d426995" title="Return a new meta::list constructed by doing a right fold of the list List using binary Callable Fun ...">meta::reverse_fold</a></code>, <code><a class="el" href="group__transformation.html#ga9ca974f63ad4bb43802cf68d3c83bb8f" title="An alias for meta::fold. ">meta::accumulate</a></code>, <code><a class="el" href="group__transformation.html#gadf83711e56c6bc24311aa68b338cac7d" title="Return a new meta::list where all duplicate elements have been removed. ">meta::unique</a></code>, <code><a class="el" href="group__transformation.html#gae3c48dcdc2c7a675f9c268d5e5ed0910" title="Return a new meta::list where all instances of type T have been replaced with U. ">meta::replace</a></code>, <code><a class="el" href="group__transformation.html#ga9564754ddab1c4a725031b1bb093a549" title="Return a new meta::list where all elements A of the list List for which invoke<C,A>::value is true ha...">meta::replace_if</a></code>, <code><a class="el" href="group__transformation.html#ga93bdbecbad3ea6e3c31362bf60d9bd9e" title="Returns a new meta::list where only those elements of List that satisfy the Callable Pred such that i...">meta::filter</a></code>, <code><a class="el" href="group__transformation.html#ga1232449533420b49364f2b3a27154cc3" title="Return a new meta::list constructed by transforming all the elements in List with the unary Callable ...">meta::transform</a></code>, <code><a class="el" href="group__transformation.html#gac34fe4c73001dab0bfa9604cb87161fc" title="Return a new meta::list by reversing the elements in the list List. ">meta::reverse</a></code>, <code><a class="el" href="group__transformation.html#gaf35ecbb4ab9fa35cdb62fc0d8c06bba5" title="Given a list of lists ListOfLists, return a new list of lists that is the Cartesian Product...">meta::cartesian_product</a></code>.</li>
<li>Math: <code><a class="el" href="group__math.html#gab5e2f54a307613cfd97223ca45fb2419" title="An integral constant wrapper around the result of adding the two wrapped integers T::type::value and ...">meta::plus</a></code> , <code><a class="el" href="group__math.html#ga5738a7d892d9bf6f281f87b556057ecb" title="An integral constant wrapper around the result of subtracting the two wrapped integers T::type::value...">meta::minus</a></code>, <code><a class="el" href="group__math.html#ga795c76535d57404cdfd5e42e247ce109" title="An integral constant wrapper around the result of multiplying the two wrapped integers T::type::value...">meta::multiplies</a></code>, <code><a class="el" href="group__math.html#ga4d16896fb397ec3ded21808fc2749b41" title="An integral constant wrapper around the result of dividing the two wrapped integers T::type::value an...">meta::divides</a></code>, <code><a class="el" href="group__math.html#ga9f3a3adf2556161e23d0b181d075498a" title="An integral constant wrapper around the result of negating the wrapped integer T::type::value. ">meta::negate</a></code>, <code><a class="el" href="group__math.html#gadb0adcf6123000b8aabccca5a6090289" title="An integral constant wrapper around the remainder of dividing the two wrapped integers T::type::value...">meta::modulus</a></code>, <code><a class="el" href="group__math.html#gadccc21f4cad9bc9971798006950c48a2" title="A Boolean integral constant wrapper around the result of comparing T::type::value and U::type::value ...">meta::equal_to</a></code>, <code><a class="el" href="group__math.html#ga0ac5f5c29d6eacedec33733d5e224ec0" title="A Boolean integral constant wrapper around the result of comparing T::type::value and U::type::value ...">meta::not_equal_to</a></code>, <code><a class="el" href="group__math.html#gaf4b1427cc9c4040ffca9845c068621ed" title="A Boolean integral constant wrapper around true if T::type::value is greater than U::type::value; fal...">meta::greater</a></code>, <code><a class="el" href="group__math.html#gabdb640343287440ca84ce0217faf7741" title="A Boolean integral constant wrapper around true if T::type::value is less than U::type::value; false...">meta::less</a></code>, <code><a class="el" href="group__math.html#ga03eb74e40109672a931e14505c90f40d" title="A Boolean integral constant wrapper around true if T::type::value is greater than or equal to U::type...">meta::greater_equal</a></code>, <code><a class="el" href="group__math.html#gab2b03f0bfd42cbb237831b6aaf2f0ef5" title="A Boolean integral constant wrapper around true if T::type::value is less than or equal to U::type::v...">meta::less_equal</a></code>, <code><a class="el" href="group__math.html#ga34d588aaca15812df2d4af67863bcfb4" title="An integral constant wrapper around the result of bitwise-and&#39;ing the two wrapped integers T::type::v...">meta::bit_and</a></code>, <code><a class="el" href="group__math.html#ga5ae6f56a9b7c7f29593cd48812ce09ca" title="An integral constant wrapper around the result of bitwise-or&#39;ing the two wrapped integers T::type::va...">meta::bit_or</a></code>, <code><a class="el" href="group__math.html#ga1bc30e36ab8d456a9907e1f16cf21976" title="An integral constant wrapper around the result of bitwise-exclusive-or&#39;ing the two wrapped integers T...">meta::bit_xor</a></code>, <code><a class="el" href="group__math.html#ga7123fd4e34449e1357f8230c1c142f58" title="An integral constant wrapper around the result of bitwise-complementing the wrapped integer T::type::...">meta::bit_not</a></code>, <code><a class="el" href="group__math.html#ga404163b581feeea816953affaa2a0394" title="An integral constant wrapper around the minimum of Ts::type::value... ">meta::min</a></code>, <code><a class="el" href="group__math.html#ga48d253d788a4c2e65ebcefef9bbdbbcb" title="An integral constant wrapper around the maximum of Ts::type::value... ">meta::max</a></code>, <code><a class="el" href="namespacemeta.html#a1b6c7023c7c03d805f0c64c8b5bb73dd" title="An integral constant wrapper around the result of incrementing the wrapped integer T::type::value...">meta::inc</a></code>, <code><a class="el" href="namespacemeta.html#aed9000d5b6ace97758eb43190482500f" title="An integral constant wrapper around the result of decrementing the wrapped integer T::type::value...">meta::dec</a></code>.</li>
<li>Run time: <code><a class="el" href="group__runtime.html#ga8beaba5ae537715c97e180b05160cc03" title="for_each(List, UnaryFunction) calls the UnaryFunction for each argument in the List. ">meta::for_each</a></code>.</li>
</ul>
<p>See the reference section for more details. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
